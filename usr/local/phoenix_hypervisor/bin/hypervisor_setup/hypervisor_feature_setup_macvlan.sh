#!/bin/bash
#
# File: hypervisor_feature_setup_macvlan.sh
# Description: Sets up Macvlan interfaces on the host using robust /etc/network/interfaces configuration.
#              This replaces the previous fragile `ip link add` method.

setup_macvlan_interfaces() {
    local config_file="$1"
    log_info "Starting Host Network Setup (Macvlan/Bridge)..."

    # --- Configuration ---
    # We read these from the JSON config to ensure data-driven setup
    local physical_nic="enp6s0" # Defaulting to standard Proxmox NIC, ideally this should be in config
    local proxmox_ip=$(jq -r '.network.interfaces.address' "$config_file")
    local gateway=$(jq -r '.network.interfaces.gateway' "$config_file")
    local vlan_tag=$(jq -r '.network.macvlan_vlan_tag // "10"' "$config_file")
    local public_vlan_tag=$(jq -r '.network.public_vlan_tag // "20"' "$config_file")
    local internal_bridge=$(jq -r '.network.internal_bridge.name // "vmbr100"' "$config_file")
    local internal_subnet=$(jq -r '.network.internal_bridge.subnet // "172.16.100.0/24"' "$config_file")
    
    # Calculate internal bridge IP (e.g., 172.16.100.1)
    local internal_ip=$(echo "$internal_subnet" | cut -d/ -f1 | sed 's/\.[0-9]*$/.1/')

    log_info "Configuration detected:"
    log_info "  Physical NIC: $physical_nic"
    log_info "  Management IP: $proxmox_ip"
    log_info "  Gateway: $gateway"
    log_info "  Macvlan VLAN Tag: $vlan_tag"
    log_info "  Public VLAN Tag: $public_vlan_tag"
    log_info "  Internal Bridge: $internal_bridge ($internal_ip)"

    # --- Backup ---
    log_info "Backing up existing network interfaces..."
    cp /etc/network/interfaces /etc/network/interfaces.phoenix.bak.$(date +%s)

    # --- Generate /etc/network/interfaces ---
    log_info "Generating new /etc/network/interfaces..."
    
    cat > /etc/network/interfaces <<EOF
# network interface settings; autogenerated by Phoenix Hypervisor
# Please do not edit this file directly.

auto lo
iface lo inet loopback

iface $physical_nic inet manual

# Management bridge - VLAN aware so we can create macvlan sub-interfaces
auto vmbr0
iface vmbr0 inet static
        address $proxmox_ip
        gateway $gateway
        bridge-ports $physical_nic
        bridge-stp off
        bridge-fd 0
        bridge-vlan-aware yes
        bridge-vids 2-4094

# Macvlan Portal (Legacy) - Public-facing containers attach here
# This effectively puts them on VLAN $vlan_tag
auto vmbr0.$vlan_tag
iface vmbr0.$vlan_tag inet manual

# Public VLAN Portal - For new public-facing architecture (e.g. Nginx)
# Using a dedicated VLAN avoids DHCP suppression issues common with macvlan on untagged bridges
auto vmbr0.$public_vlan_tag
iface vmbr0.$public_vlan_tag inet manual
        vlan-raw-device vmbr0

# Private Internal Bridge - For isolated traffic (Traefik, Step-CA)
auto $internal_bridge
iface $internal_bridge inet static
        address $internal_ip/24
        bridge-ports none
        bridge-stp off
        bridge-fd 0

        # Enable forwarding
        post-up echo 1 > /proc/sys/net/ipv4/ip_forward
        post-down echo 0 > /proc/sys/net/ipv4/ip_forward

        # NAT masquerade so internal mesh can reach Internet
        # Using -C to check existence avoids duplication
        post-up iptables -t nat -C POSTROUTING -s $internal_subnet -o vmbr0 -j MASQUERADE 2>/dev/null || iptables -t nat -A POSTROUTING -s $internal_subnet -o vmbr0 -j MASQUERADE
        post-down iptables -t nat -D POSTROUTING -s $internal_subnet -o vmbr0 -j MASQUERADE 2>/dev/null || true

        # Forwarding rules - Insert at TOP (-I 1) to bypass PVE Firewall drops
        # 1. Allow outgoing traffic from internal bridge to wan
        post-up iptables -C FORWARD -i $internal_bridge -o vmbr0 -j ACCEPT 2>/dev/null || iptables -I FORWARD 1 -i $internal_bridge -o vmbr0 -j ACCEPT
        post-down iptables -D FORWARD -i $internal_bridge -o vmbr0 -j ACCEPT 2>/dev/null || true

        # 2. Allow return traffic (Established/Related) from wan to internal bridge
        post-up iptables -C FORWARD -i vmbr0 -o $internal_bridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || iptables -I FORWARD 1 -i vmbr0 -o $internal_bridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
        post-down iptables -D FORWARD -i vmbr0 -o $internal_bridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true

# Unused interfaces (kept manual to prevent interference)
iface enp13s0 inet manual
iface wlp7s0 inet manual

source /etc/network/interfaces.d/*
EOF

    # --- DNS Configuration ---
    # Ensure DNS is set correctly in resolv.conf
    # We use the first nameserver from config as primary
    local dns_primary=$(jq -r '.network.interfaces.dns_nameservers[0] // "8.8.8.8"' "$config_file")
    local dns_fallback="8.8.8.8"
    
    log_info "Configuring DNS ($dns_primary, $dns_fallback)..."
    cat > /etc/resolv.conf <<EOF
nameserver $dns_primary
nameserver $dns_fallback
EOF

    # --- Apply Configuration ---
    log_info "Applying network configuration using ifreload..."
    if command -v ifreload >/dev/null 2>&1; then
        ifreload -a
    else
        log_warn "ifreload not found. Attempting 'systemctl reload networking'..."
        systemctl reload networking
    fi

    # --- Verification ---
    log_info "Verifying network state..."
    sleep 5
    
    if ip link show "vmbr0.$vlan_tag" >/dev/null 2>&1; then
        log_success "Legacy Macvlan portal vmbr0.$vlan_tag is UP."
    else
        log_error "Legacy Macvlan portal vmbr0.$vlan_tag failed to come up."
    fi

    if ip link show "vmbr0.$public_vlan_tag" >/dev/null 2>&1; then
        log_success "Public VLAN portal vmbr0.$public_vlan_tag is UP."
    else
        log_error "Public VLAN portal vmbr0.$public_vlan_tag failed to come up."
    fi

    if ip link show "$internal_bridge" >/dev/null 2>&1; then
        log_success "Internal bridge $internal_bridge is UP."
    else
        log_error "Internal bridge $internal_bridge failed to come up."
    fi
}

# This script is intended to be sourced, but we can allow direct execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # SCRIPT_DIR needs to be defined for standalone execution
    SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &> /dev/null && pwd)
    source "${SCRIPT_DIR}/../phoenix_hypervisor_common_utils.sh"
    
    # Check for config argument
    if [ -z "$1" ]; then
        echo "Usage: $0 <path_to_config_file>"
        exit 1
    fi
    
    setup_macvlan_interfaces "$1"
fi