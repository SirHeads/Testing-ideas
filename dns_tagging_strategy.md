# Detailed Explanation: `dnsmasq` Tagging for True Split-Horizon DNS

This document provides a detailed breakdown of the `dnsmasq` tagging strategy we will implement to resolve the current DNS conflict and create a robust, context-aware internal DNS system.

## 1. The "What" and "Why": Understanding the Problem

Currently, our `dnsmasq` server is loading two different "phone books" (configuration files) that contain conflicting information for the same names.

*   `00-phoenix-internal-hosts.conf`: Says `portainer.phoenix.thinkheads.ai` is at `10.0.0.12` (Traefik).
*   `01-phoenix-external-sim.conf`: Says `portainer.phoenix.thinkheads.ai` is at `10.0.0.153` (Nginx).

When a client (like the hypervisor) asks for `portainer.phoenix.thinkheads.ai`, `dnsmasq` is sending back **both** addresses. This is causing the health check to fail and would lead to unpredictable behavior for your internal services.

The core issue is that `dnsmasq` doesn't know **who** is asking. It gives the same answer to everyone, regardless of their location on the network.

## 2. The "How": The `dnsmasq` Tagging Solution

The solution is to make `dnsmasq` context-aware. We will tell it to give different answers based on where the request is coming from. We achieve this using a standard `dnsmasq` feature called "tagging".

The implementation involves two precise changes:

### Change 1: Tagging the Traffic

First, we will add a single line to the main `dnsmasq.conf` file. This file is generated by the `hypervisor_feature_setup_dns_server.sh` script.

```ini
# Add this line to /etc/dnsmasq.conf
dhcp-host-tag=set:internal,interface:vmbr0
```

**What this does:**
This line tells `dnsmasq`: "Any DNS request that arrives on the `vmbr0` network interface, 'tag' it with the label `internal`." Since all of your VMs and LXC containers are connected to this bridge, this effectively tags all of your internal services. The hypervisor host itself does not use this interface for its own DNS queries, so its requests will remain untagged.

### Change 2: Assigning Records to Tags

Second, we will modify the `hypervisor_feature_setup_dns_server.sh` script to add a special line to the top of each generated hosts file.

**File 1: `00-phoenix-internal-hosts.conf`**
```ini
# This line will be added at the top
conf-file=/etc/dnsmasq.d/00-phoenix-internal-hosts.conf,internal

# Generated Records...
address=/portainer.phoenix.thinkheads.ai/10.0.0.12
address=/qdrant.phoenix.thinkheads.ai/10.0.0.12
...
```
**What this does:**
The `conf-file=...,internal` directive tells `dnsmasq`: "**Only** use the records in this file if the request has the `internal` tag."

**File 2: `01-phoenix-external-sim.conf`**
```ini
# This line will be added at the top
conf-file=/etc/dnsmasq.d/01-phoenix-external-sim.conf,tag:!internal

# Generated Records...
address=/portainer.phoenix.thinkheads.ai/10.0.0.153
address=/qdrant.phoenix.thinkheads.ai/10.0.0.153
...
```
**What this does:**
The `conf-file=...,tag:!internal` directive tells `dnsmasq`: "**Only** use the records in this file if the request does **not** have the `internal` tag."

## 3. The Result: A True Split-Horizon DNS

After these changes, the system will behave exactly as intended:

*   **An internal service (e.g., VM 1002)** sends a DNS query. It arrives on `vmbr0`, gets tagged `internal`. `dnsmasq` sees the tag and only uses the `00-phoenix-internal-hosts.conf` file, correctly returning the Traefik IP (`10.0.0.12`).
*   **The hypervisor host** sends a DNS query (for our health check). It does not arrive on `vmbr0`, so it has no tag. `dnsmasq` sees the lack of a tag and only uses the `01-phoenix-external-sim.conf` file, correctly returning the Nginx Gateway IP (`10.0.0.153`).

This resolves the conflict, eliminates the race condition, and makes your internal DNS robust, reliable, and perfectly aligned with your dual-horizon architecture.